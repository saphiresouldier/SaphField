// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//includes
#include "Assets/Shaders/primitives.glslinc"
#include "Assets/Shaders/operations.glslinc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4 _DirectionalLight;
float2 _PixelOffset;
float _SkyboxTexFactor;

//Skybox Texture
Texture2D<float4> _SkyboxTex;
SamplerState sampler_SkyboxTex;

//Constants
static const float PI = 3.14159265f;
static const float EPSILON = 0.00001f;
static const float SDF_DIST = .01;
static const float RAYMARCH_STEPS = 250;
static const float MAX_DIST = 50.0;

//randomness
float2 _CurPixel;
float _Seed;

struct Ray
{
  float3 origin;
  float3 direction;
	float3 energy;
};

struct SDF
{
  float3 pos, rot, scale, color;
  float smoothRange;
  int opType;
  int shape;
};

struct SDFReturn
{
  float distance;
  float3 color;
};

float rand()
{
	float result = frac(sin(_Seed / 100.0f * dot(_CurPixel, float2(12.9898f, 78.233f))) * 43758.5453f);
	_Seed += 1.0f;
	return result;
}

float sdot(float3 i, float3 o, float f = 1.0f)
{
	return saturate(dot(i, o) * f);
}

//Structured Buffers
StructuredBuffer<SDF> _SDFs;

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}

SDFReturn CreateSDFReturn(float distance, float3 color)
{
  SDFReturn ret;
  ret.distance = distance;
  ret.color = color;
  return ret;
}

Ray CreateCameraRay(float2 uv)
{
//transform camera origin in world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
// Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;

// Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

float3x3 GetTangentSpace(float3 normal)
{
	//choose helper vector based on axis alignment
	float3 axisHelper = float3(1, 0, 0);
	if (abs(normal.x) > 0.99f) axisHelper = float3(0, 0, 1);

	//Generate tangent vectors
	float3 tangent = normalize(cross(normal, axisHelper));
	float3 binormal = normalize(cross(normal, tangent));

	return float3x3(tangent, binormal, normal);
}

float3 SampleHemisphere(float3 normal, float alpha)
{
	// Sample hemisphere direction, alpha factor decides kind of sampling
	float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));
	float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
	float phi = 2 * PI * rand();
	float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);

	// Transform direction to world space
	return mul(tangentSpaceDir, GetTangentSpace(normal));
}

float GetShapeDistance(SDF sdf,float3 p)
{
  // TODO transform matrix

  if (sdf.shape == 1) return signedDistancePlane(p - sdf.pos.xyz, float3(0.0, 1.0, 0.0), 0.0);
  else if (sdf.shape == 2) return signedDistanceCone(p - sdf.pos.xyz, float2(0.5, 0.5), 1.0);
  // TODO more shape support
  else return signedDistanceSphere(p, sdf.pos.xyz, sdf.scale.x * 0.5f);
}

SDFReturn opCombine(float global_d, float local_d, float3 global_col, float3 local_col, int operation, float blend)
{
  SDFReturn r = CreateSDFReturn(global_d, global_col);

  if (operation == 0)
  {
    float4 o = opSmoothUnion(global_d, local_d, global_col, local_col, blend);
    r.distance = o.x;
    r.color = o.yzw;
  }
  else if (operation == 1)
  {
    r.distance = opSmoothSubtraction(global_d, local_d, blend);
  }
  else if (operation == 2)
  {
    r.distance = opSmoothIntersection(global_d, local_d, blend);
  }

  return r;
}

// scene SDF
SDFReturn GetSceneDistanceAndColorFromPoint(float3 p) 
{
  uint numSDFs, strideSDFs;
  _SDFs.GetDimensions(numSDFs, strideSDFs);

  SDFReturn global_combined = CreateSDFReturn(MAX_DIST, float3(1.0, 1.0, 1.0));

  for( uint i = 0; i < numSDFs; i++)
  {
    float local_dist = GetShapeDistance(_SDFs[i], p);
    float3 local_col = _SDFs[i].color;

    // TODO handle children+nesting+layers here

    global_combined = opCombine(global_combined.distance, local_dist, global_combined.color, local_col, _SDFs[i].opType, _SDFs[i].smoothRange);
  }

  return global_combined;
}

// TODO faster shading computation rays without color computation
float3 calcNormalFast(float3 p)
{
  float dist = GetSceneDistanceAndColorFromPoint(p).distance;
  float3 epsilon = float3(0.0001, 0.0001, 0.0001);
  return normalize(dist - float3(GetSceneDistanceAndColorFromPoint(p - epsilon.xyy).distance,
                                 GetSceneDistanceAndColorFromPoint(p - epsilon.yxy).distance,
                                 GetSceneDistanceAndColorFromPoint(p - epsilon.yyx).distance));
}

// TODO faster shading computation rays without color computation
// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
float3 calcNormalEfficient(float3 p)
{
  const float ep = 0.0001;
  float2 e = float2(1.0, -1.0)*0.5773;
  return normalize( e.xyy*GetSceneDistanceAndColorFromPoint(p + e.xyy*ep).distance +
                    e.yyx*GetSceneDistanceAndColorFromPoint(p + e.yyx*ep).distance +
                    e.yxy*GetSceneDistanceAndColorFromPoint(p + e.yxy*ep).distance +
                    e.xxx*GetSceneDistanceAndColorFromPoint(p + e.xxx*ep).distance);
}

SDFReturn Raymarch(Ray r)
{
  SDFReturn ret;
  ret.color = float3(1.0, 1.0, 0.0);

  float dist_0 = 0.0; //distance from origin

  // main raymarch loop
  for (int i = 0; i < RAYMARCH_STEPS; i++) {

    // march ray from origin in direction
    float3 t = r.origin + r.direction * dist_0;

    // get distance
    SDFReturn r = GetSceneDistanceAndColorFromPoint(t);

    //advance/march along ray - spheretracing
    dist_0 += r.distance;

    //compute sdf
    if (dist_0 > MAX_DIST || r.distance < SDF_DIST) {
      // found a hit
      ret.distance = dist_0;
      ret.color = r.color;
      return ret;
    }
  }

  ret.distance = MAX_DIST;
  return ret;
}

float calcShading(float3 p)
{
  // light source
  float3 light_position = _DirectionalLight.xyz;

  // light direction
  float3 light_dir = normalize(light_position - p);

  // calculate hitpoint normal (gradient of sdf at p)
  float3 normal = calcNormalEfficient(p);

  // calculate diffuse contribution
  float diffuse_contrib = clamp(dot(normal, light_dir), 0.0, 1.0);

  // calculate shadow rays
  Ray shadowray;
  shadowray.origin = p + normal * SDF_DIST * 2.0;
  shadowray.direction = light_dir;
  float shadow_ret = Raymarch(shadowray).distance; // TODO faster shadow computation rays without color computation

  // in shadow
  if (shadow_ret < length(light_position - p)) diffuse_contrib *= 0.5;

  return diffuse_contrib;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

	//initialize current pixel for randomness
	_CurPixel = id.xy;

	// Get the dimensions of the RenderTexture
  uint width, height;
  Result.GetDimensions(width, height);

	// Transform pixel to [-1,1] range
  float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);

	// Get a ray for the UVs
  Ray ray = CreateCameraRay(uv);

	//Trace and Shade
  float3 result = float3(0, 0, 0);

  // raymarching
  SDFReturn m = Raymarch(ray);

  if (m.distance < MAX_DIST) {
    // calculate hit point
    float3 hitpoint = ray.origin + ray.direction * m.distance;

    // shade point
    float diffuse = calcShading(hitpoint);
    result = m.color * diffuse;
  }
  else
  {
    // background
    float y = (uv.y + 1.0f) / 2.0f;
    result = float3(y, y, y);
  }

  Result[id.xy] = float4(result, 1);
}
